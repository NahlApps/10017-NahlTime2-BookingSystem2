/** =======================================================================
 * NahlHub â€” Code.gs (FULL VERSION)
 * -----------------------------------------------------------------------
 * Roles:
 *  - Main entry + routing (doGet/doPost)
 *  - Schema bootstrap (ensureSchema)
 *  - Public Hub APIs (bootstrap, list/install/uninstall apps, token issue)
 *  - Admin APIs (list/add/update/delete entities with role enforcement)
 *  - Secret management (rotate, resend config)
 *  - Minimal perf hooks + test runners
 * 
 * Deployment Steps
 *  1) Bind this Apps Script project to your Admin Spreadsheet (container-bound).
 *  2) Set Script Properties (File â†’ Project properties â†’ Script properties):
 *     - GOOGLE_CLIENT_ID = your-web-client-id.apps.googleusercontent.com
 *     - STRIPE_WEBHOOK_SECRET = whsec_xxx
 *     - (Hub will also create APP_SECRET:<install_id> entries)
 *  3) File structure: keep other .gs files alongside (security, sheets, webhooks,
 *     billing, telemetry, lint, auth, stripe_webhook, themes, OntimeRun),
 *     and HTML includes (index.html, nahl-ds.html, view-*.html).
 *  4) Deploy (Deploy â†’ New Deployment â†’ Web App â†’ Execute as Me, Anyone).
 * 
 * Required Scopes (auto-granted by Apps Script as needed)
 *  - Spreadsheet (read/write)
 *  - Drive (export JSON)
 *  - URL Fetch (token verify, webhooks)
 *  - Script Properties, Cache, Lock
 * 
 * Advanced Services: none required (using UrlFetchApp directly).
 * 
 * Sample Script Properties Setup (run once in Apps Script console):
 *  setProp_('GOOGLE_CLIENT_ID', 'YOUR_WEB_CLIENT_ID.apps.googleusercontent.com');
 *  setProp_('STRIPE_WEBHOOK_SECRET', 'whsec_xxx');
 * 
 * Notes
 *  - Per-Install Secret is stored as Script Property key: APP_SECRET:<install_id>
 *  - All write operations aim to be concurrency-safe; we use simple guards
 *    (LockService inside other modules where needed).
 *  - All public APIs return {ok:boolean, ...} and avoid throwing to the client.
 * ======================================================================= */

/* ------------------------------- Constants ------------------------------ */

const HUB_TITLE     = 'Nahl Hub';
const TOKEN_TTL_SEC = 10 * 60; // 10 minutes
const SHEETS = {
  Tenants:       'Tenants',
  Users:         'Users',
  Apps:          'Apps',
  Plans:         'Plans',
  Subscriptions: 'Subscriptions',
  AppInstalls:   'AppInstalls',
  AuditLogs:     'AuditLogs',
  Telemetry:     'Telemetry'
};

/* ------------------------------ Shortcuts ------------------------------- */

// Spreadsheet handle (container-bound recommended)
function ss() {
  try { return SpreadsheetApp.getActive(); }
  catch (e) { throw new Error('Bind this Apps Script to the Admin Spreadsheet.'); }
}

// Sheet accessor helper (used in this file)
function sheet_(name){
  const sh = ss().getSheetByName(name);
  if (!sh) throw new Error('Missing sheet: ' + name);
  return sh;
}

// HTML include helper (used by index.html)
function include(name){ return HtmlService.createHtmlOutputFromFile(name).getContent(); }

// Safe-call wrapper for public endpoints
function safeCall_(fn){
  try { return fn(); }
  catch(e){
    const msg = String(e && e.message ? e.message : e);
    Logger.log(JSON.stringify({level:'error', fn:'safeCall_', msg}));
    return {ok:false, error: msg};
  }
}

// (Optional) perf hook: time a function and emit telemetry (if available)
function timeIt_(label, fn){
  const t0 = Date.now();
  try { return fn(); }
  finally {
    const ms = Date.now() - t0;
    try { emitTelemetry_({tenant_id:'', app_id:'', event:'perf.'+label, meta:{}, ms}); } catch (_) {}
    Logger.log(JSON.stringify({ts:new Date().toISOString(), event:'perf', label, ms}));
  }
}

/* --------------------------- HTTP Entrypoints --------------------------- */

function doGet(e) {
  ensureSchema();
  return HtmlService.createTemplateFromFile('index')
    .evaluate()
    .setTitle(HUB_TITLE)
    .addMetaTag('viewport', 'width=device-width, initial-scale=1')
    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);
}

/** Unified doPost router (optional).
 *  Webhook endpoints (Stripe) â†’ route using e.parameter.route='stripe'
 */
function doPost(e) {
  const route = (e && e.parameter && e.parameter.route) || '';
  if (route === 'stripe') return stripe_handleWebhook(e);
  return ContentService.createTextOutput(JSON.stringify({ok:false, error:'No route'}))
    .setMimeType(ContentService.MimeType.JSON)
    .setResponseCode(404);
}

/* --------------------------- Schema & Seeding --------------------------- */

function ensureSchema() {
  // Create sheets if missing
  Object.values(SHEETS).forEach(name => { if (!ss().getSheetByName(name)) ss().insertSheet(name); });
  // Headers
  setHeaders_(SHEETS.Tenants,       ['id','name','slug','domain','logo_url','status','created_at','primary','surface','page']);
  setHeaders_(SHEETS.Users,         ['id','tenant_id','email','name','role','status']);
  setHeaders_(SHEETS.Apps,          ['id','slug','title','vendor','icon','category','entry_url','frame_ancestors','settingsSchema','pricing','version','status','onInstallUrl','onUninstallUrl','description']);
  setHeaders_(SHEETS.Plans,         ['id','app_id','name','price_month','price_year','features_json']);
  setHeaders_(SHEETS.Subscriptions, ['id','tenant_id','app_id','plan_id','status','started_at','renew_at','stripe_customer_id','stripe_subscription_id']);
  setHeaders_(SHEETS.AppInstalls,   ['id','tenant_id','app_id','plan_id','config_json','installed_by','installed_at','status']);
  setHeaders_(SHEETS.AuditLogs,     ['id','tenant_id','actor','action','target','payload_json','created_at']);
  setHeaders_(SHEETS.Telemetry,     ['ts','tenant_id','app_id','event','meta_json']);

  // Seed demo tenant/user/app if empty
  if (getAll_(SHEETS.Tenants).length === 0) {
    add_(SHEETS.Tenants, { id: cuid_(), name:'Demo Co', slug:'demo', domain:'demo.nahl.app',
      logo_url:'', status:'active', created_at:nowIso_(), primary:'#2563eb', surface:'#ffffff', page:'#f7f6f3' });
  }
  const tenant = getAll_(SHEETS.Tenants)[0];
  if (getAll_(SHEETS.Users).length === 0) {
    add_(SHEETS.Users, { id:cuid_(), tenant_id:tenant.id, email:'owner@demo.com', name:'Owner', role:'Owner', status:'active' });
  }
  if (getAll_(SHEETS.Apps).length === 0) {
    add_(SHEETS.Apps, {
      id: cuid_(),
      slug: 'booking-calendar',
      title: 'Booking Calendar',
      vendor: 'Nahl',
      icon: 'ðŸ“…',
      category: 'Operations',
      entry_url: 'https://example.com/booking', // TODO: replace
      frame_ancestors: JSON.stringify(['https://script.google.com','https://*.googleusercontent.com']),
      settingsSchema: JSON.stringify([
        {"key":"BUSINESS_NAME","label":"Business Name","type":"string","required":true},
        {"key":"TIMEZONE","label":"Timezone","type":"string","required":true}
      ]),
      pricing: JSON.stringify({ plans:[{name:'Starter',price_month:19},{name:'Pro',price_month:49}] }),
      version: '1.0.0',
      status: 'public',
      onInstallUrl: '', onUninstallUrl: '',
      description: 'Simple booking calendar demo app.'
    });
  }
}

/* ------------------------------ Public APIs ---------------------------- */

/** Demo bootstrap by email (for testing). Prefer hub_bootstrap_google() for production. */
function hub_bootstrap(email){
  return safeCall_(()=> timeIt_('hub_bootstrap', () => {
    ensureSchema();
    const norm = String(email||'').toLowerCase();
    const users = getAll_(SHEETS.Users).filter(u => String(u.email).toLowerCase() === norm);
    const tenants = users.map(u => findById_(SHEETS.Tenants, u.tenant_id)).filter(Boolean);
    const apps = hub_listApps();
    const installs = getAll_(SHEETS.AppInstalls).filter(i => tenants.some(t => t.id === i.tenant_id));
    return { ok:true, me:{email:norm}, tenants, users, apps, installs };
  }));
}

function hub_listApps(){ return getAll_(SHEETS.Apps).filter(a => a.status === 'public'); }

function hub_listInstalls(tenant_id){
  return getAll_(SHEETS.AppInstalls).filter(i => i.tenant_id === tenant_id && i.status === 'active');
}

/** Install flow: create AppInstalls row, generate secret, optional webhook */
function hub_installApp(payload){
  return safeCall_(()=> timeIt_('hub_installApp', () => {
    const { tenant_id, app_id, plan_id, settings, actor_email } = payload || {};
    const app = findById_(SHEETS.Apps, app_id);
    if (!app) throw new Error('App not found');

    // Validate plan
    let chosenPlan = plan_id || '';
    if (chosenPlan){
      const plan = getAll_(SHEETS.Plans).find(p=>p.app_id===app_id && p.name===chosenPlan);
      if (!plan) throw new Error('Invalid plan_id: '+chosenPlan);
    } else {
      const plan = getAll_(SHEETS.Plans).find(p=>p.app_id===app_id);
      chosenPlan = plan ? plan.name : '';
    }

    // Ensure subscription exists (trial)
    const sub = getAll_(SHEETS.Subscriptions).find(s => s.tenant_id===tenant_id && s.app_id===app_id);
    if (!sub) {
      add_(SHEETS.Subscriptions, { id:cuid_(), tenant_id, app_id, plan_id: chosenPlan, status:'trial', started_at:nowIso_(), renew_at:'' });
    }

    // Add install row
    const install_id = cuid_();
    add_(SHEETS.AppInstalls, {
      id: install_id, tenant_id, app_id, plan_id: chosenPlan,
      config_json: JSON.stringify(settings||{}),
      installed_by: actor_email||'', installed_at: nowIso_(), status:'active'
    });

    // Store secret
    const secret = generateSecret_();
    setProp_('APP_SECRET:'+install_id, secret);

    // Logs
    audit_({tenant_id, actor: actor_email||'', action:'app.installed', target: app_id, payload:{install_id, plan_id:chosenPlan}});
    emitTelemetry_({tenant_id, app_id, event:'app.installed', meta:{plan_id:chosenPlan}});

    // Call webhook
    if (app.onInstallUrl) {
      callOnInstallWebhook_({
        url: app.onInstallUrl,
        body: { install_id, tenant_id, app_id: app.id, secret, config: settings || {} }
      });
    }

    return { ok:true, install_id };
  }));
}

/** Uninstall flow: mark inactive, delete secret, optional webhook */
function hub_uninstallApp(install_id, actor_email){
  return safeCall_(()=> timeIt_('hub_uninstallApp', () => {
    const inst = findById_(SHEETS.AppInstalls, install_id);
    if (!inst) throw new Error('Install not found');
    if (inst.status === 'inactive') return {ok:true, already:true};

    // Mark inactive (in-place update)
    const sh = sheet_(SHEETS.AppInstalls);
    const hm = headerMap_(sh);
    const last = sh.getLastRow();
    if (last > 1){
      const vals = sh.getRange(2,1,last-1, sh.getLastColumn()).getValues();
      for (let i=0;i<vals.length;i++){
        if (String(vals[i][hm.id]) === String(install_id)){
          vals[i][hm.status] = 'inactive';
          sh.getRange(i+2,1,1,vals[i].length).setValues([vals[i]]);
          break;
        }
      }
    }

    // Remove secret
    PropertiesService.getScriptProperties().deleteProperty('APP_SECRET:'+install_id);

    // Call webhook if app defines onUninstallUrl
    const app = findById_(SHEETS.Apps, inst.app_id);
    if (app?.onUninstallUrl){
      callOnUninstallWebhook_({
        url: app.onUninstallUrl,
        body: { install_id, tenant_id:inst.tenant_id, app_id:app.id }
      });
    }

    audit_({tenant_id:inst.tenant_id, actor:actor_email||'', action:'app.uninstalled', target:inst.app_id, payload:{install_id}});
    emitTelemetry_({tenant_id:inst.tenant_id, app_id:inst.app_id, event:'app.uninstalled', meta:{actor_email:actor_email||''}});

    return {ok:true, uninstall_id:install_id};
  }));
}

/** Issue HMAC token (short lived) for iframe apps */
function hub_issueToken(install_id, actor_email){
  return safeCall_(()=> timeIt_('hub_issueToken', () => {
    rateLimitOrThrow_('issue:'+actor_email+':'+install_id, 10, 60); // 10/min

    const install = findById_(SHEETS.AppInstalls, install_id);
    if (!install) throw new Error('Install not found');
    const app = findById_(SHEETS.Apps, install.app_id);
    if (!app) throw new Error('App not found');
    const user = getAll_(SHEETS.Users).find(u => String(u.email).toLowerCase()===String(actor_email||'').toLowerCase() && u.tenant_id===install.tenant_id);
    if (!user) throw new Error('User not in tenant');

    // enforce entitlements
    enforceSubscriptionOrThrow_(install.tenant_id, app.id);

    const iat = Math.floor(Date.now()/1000);
    const exp = iat + TOKEN_TTL_SEC;
    const payload = {
      iss:'nahl.hub', aud: app.id,
      tenant_id: install.tenant_id,
      user: { email:user.email, name:user.name, role:user.role },
      install_id, iat, exp
    };

    const secret = getProp_('APP_SECRET:'+install_id);
    if (!secret) throw new Error('Install secret missing');
    const token = signHmacToken_(payload, secret);

    audit_({tenant_id: install.tenant_id, actor: actor_email||'', action:'token.issued', target: install_id, payload:{aud: app.id, exp}});
    emitTelemetry_({tenant_id: install.tenant_id, app_id: app.id, event:'app.opened', meta:{actor_email:actor_email||''}});

    return { ok:true, token, payload };
  }));
}

/** Secret rotation (Admin action) + optional notify app */
function rotateInstallSecret(install_id, actor_email){
  return safeCall_(()=> {
    const inst = findById_(SHEETS.AppInstalls, install_id);
    if (!inst) throw new Error('Install not found');

    const newSecret = generateSecret_();
    setProp_('APP_SECRET:'+install_id, newSecret);

    audit_({tenant_id:inst.tenant_id, actor:actor_email||'system', action:'secret.rotated', target:install_id});

    // Notify app if webhook exists
    let webhook = {attempted:false, ok:false, status:null};
    const app = findById_(SHEETS.Apps, inst.app_id);
    if (app?.onInstallUrl) {
      webhook.attempted = true;
      const res = callOnInstallWebhook_({
        url: app.onInstallUrl,
        body: {
          install_id,
          tenant_id: inst.tenant_id,
          app_id: app.id,
          secret: newSecret,
          config: JSON.parse(inst.config_json || '{}')
        }
      });
      webhook.ok = !!res?.ok;
      webhook.status = res?.status ?? null;
    }

    return {ok:true, webhook};
  });
}

/** Resend current secret + config to onInstallUrl (no rotation) */
function resendInstallConfig(install_id, actor_email){
  return safeCall_(()=>{
    const inst = findById_(SHEETS.AppInstalls, install_id);
    if (!inst) throw new Error('Install not found');

    const app = findById_(SHEETS.Apps, inst.app_id);
    if (!app) throw new Error('App not found');
    if (!app.onInstallUrl) throw new Error('App has no onInstallUrl configured');

    // Load or regenerate secret if missing
    let secret = getProp_('APP_SECRET:'+install_id);
    let regenerated = false;
    if (!secret){
      secret = generateSecret_();
      setProp_('APP_SECRET:'+install_id, secret);
      regenerated = true;
      audit_({tenant_id:inst.tenant_id, actor:actor_email||'system', action:'secret.generated', target:install_id});
    }

    const payload = {
      install_id,
      tenant_id: inst.tenant_id,
      app_id: app.id,
      secret,
      config: JSON.parse(inst.config_json || '{}')
    };
    const result = callOnInstallWebhook_({ url: app.onInstallUrl, body: payload }); // {ok,status}

    audit_({
      tenant_id: inst.tenant_id,
      actor: actor_email||'system',
      action: 'onInstall.resend',
      target: app.id,
      payload: { install_id, status: result?.status || null, ok: !!result?.ok, regenerated }
    });

    return { ok: !!result?.ok, status: result?.status || null, regeneratedSecret: regenerated };
  });
}

/** Lint apps sheet for JSON and URLs */
function hub_lintAppsSheet(){ return safeCall_(()=> lintAppsSheet()); }

/** Return per-tenant theme vars */
function hub_getTenantTheme(tenant_id){ return safeCall_(()=> getTenantTheme(tenant_id)); }

/* ------------------------------ Admin APIs ----------------------------- */

// Ensure caller has Owner/Admin role
function requireAdmin_(actor_email){
  const norm = String(actor_email||'').toLowerCase();
  const user = getAll_(SHEETS.Users).find(u => String(u.email).toLowerCase()===norm);
  if (!user) throw new Error('User not found');
  if (!['Owner','Admin'].includes(user.role)) throw new Error('Permission denied');
  return user.tenant_id;
}

// Read helpers
function admin_listTenants(actor_email){ return safeCall_(()=>{ requireAdmin_(actor_email); return getAll_(SHEETS.Tenants); }); }
function admin_listUsers(actor_email){ return safeCall_(()=>{ requireAdmin_(actor_email); return getAll_(SHEETS.Users); }); }
function admin_listApps(actor_email){ return safeCall_(()=>{ requireAdmin_(actor_email); return getAll_(SHEETS.Apps); }); }

// Create helpers
function admin_addTenant(actor_email, tenant){
  return safeCall_(()=>{
    requireAdmin_(actor_email);
    const t = Object.assign({}, tenant);
    t.id = cuid_();
    t.created_at = nowIso_();
    t.status = t.status || 'active';
    t.primary = t.primary || '#2563eb';
    t.surface = t.surface || '#ffffff';
    t.page = t.page || '#f7f6f3';
    add_(SHEETS.Tenants, t);
    audit_({tenant_id:t.id, actor:actor_email||'', action:'tenant.add', target:t.id, payload:t});
    return {ok:true, tenant:t};
  });
}

function admin_addUser(actor_email, user){
  return safeCall_(()=>{
    requireAdmin_(actor_email);
    const u = Object.assign({}, user);
    u.id = cuid_();
    u.role = u.role || 'Member';
    u.status = u.status || 'active';
    add_(SHEETS.Users, u);
    audit_({tenant_id:u.tenant_id||'', actor:actor_email||'', action:'user.add', target:u.id, payload:u});
    return {ok:true, user:u};
  });
}

function admin_addApp(actor_email, app){
  return safeCall_(()=>{
    requireAdmin_(actor_email);
    const a = Object.assign({
      vendor:'Custom', icon:'ðŸ“¦', category:'Misc',
      frame_ancestors:'[]', settingsSchema:'[]', pricing:'{"plans":[]}',
      version:'1.0.0', status:'public', description:''
    }, app);
    a.id = cuid_();
    add_(SHEETS.Apps, a);
    audit_({tenant_id:'', actor:actor_email||'', action:'app.add', target:a.id, payload:a});
    return {ok:true, app:a};
  });
}

/* -------- Admin update/delete with Last-Owner guardrails -------- */

function getUserById_(id){
  return getAll_(SHEETS.Users).find(u => String(u.id) === String(id)) || null;
}

function isLastActiveOwner_(tenant_id, excludeUserId){
  const users = getAll_(SHEETS.Users).filter(u => String(u.tenant_id) === String(tenant_id));
  const owners = users.filter(u =>
    u.role === 'Owner' &&
    u.status !== 'disabled' && u.status !== 'inactive' &&
    String(u.id) !== String(excludeUserId)
  );
  return owners.length === 0;
}

function admin_updateUser(actor_email, userId, patch){
  return safeCall_(() => {
    requireAdmin_(actor_email);
    const user = getUserById_(userId);
    if (!user) throw new Error('User not found');

    const nextRole   = (patch && patch.role)   ? String(patch.role)   : user.role;
    const nextStatus = (patch && patch.status) ? String(patch.status) : user.status;

    const changingOwnerToNonOwner = (user.role === 'Owner' && nextRole !== 'Owner');
    const disablingOwner          = (user.role === 'Owner' && (nextStatus === 'disabled' || nextStatus === 'inactive'));

    if ((changingOwnerToNonOwner || disablingOwner) && isLastActiveOwner_(user.tenant_id, user.id)){
      throw new Error('Cannot modify the last active Owner for this tenant.');
    }

    const sh = sheet_(SHEETS.Users);
    const hm = headerMap_(sh);
    const lr = sh.getLastRow();
    if (lr < 2) throw new Error('Users sheet is empty');

    const range = sh.getRange(2,1,lr-1, sh.getLastColumn());
    const vals = range.getValues();
    let updated = null;

    for (let i=0;i<vals.length;i++){
      if (String(vals[i][hm.id]) === String(userId)){
        const row = vals[i];
        if (patch && typeof patch.role   !== 'undefined') row[hm.role]   = patch.role;
        if (patch && typeof patch.status !== 'undefined') row[hm.status] = patch.status;
        if (patch && typeof patch.name   !== 'undefined') row[hm.name]   = patch.name;
        range.offset(i,0,1,row.length).setValues([row]);
        updated = {
          id: row[hm.id],
          tenant_id: row[hm.tenant_id],
          email: row[hm.email],
          name: row[hm.name],
          role: row[hm.role],
          status: row[hm.status]
        };
        break;
      }
    }
    if (!updated) throw new Error('Row not found for update');

    audit_({
      tenant_id: updated.tenant_id,
      actor: actor_email||'',
      action: 'user.update',
      target: updated.id,
      payload: { patch }
    });
    return {ok:true, user:updated};
  });
}

function admin_deleteUser(actor_email, userId){
  return safeCall_(() => {
    requireAdmin_(actor_email);
    const user = getUserById_(userId);
    if (!user) throw new Error('User not found');

    if (user.role === 'Owner' && isLastActiveOwner_(user.tenant_id, user.id)){
      throw new Error('Cannot delete the last active Owner for this tenant.');
    }

    const sh = sheet_(SHEETS.Users);
    const hm = headerMap_(sh);
    const lr = sh.getLastRow();
    if (lr < 2) return {ok:true, deleted:false};

    const vals = sh.getRange(2,1,lr-1, sh.getLastColumn()).getValues();
    let delRowIndex = -1;

    for (let i=0;i<vals.length;i++){
      if (String(vals[i][hm.id]) === String(userId)){
        delRowIndex = i + 2; // absolute row index (1-based)
        break;
      }
    }
    if (delRowIndex === -1) return {ok:true, deleted:false};

    sh.deleteRow(delRowIndex);
    audit_({
      tenant_id: user.tenant_id,
      actor: actor_email||'',
      action: 'user.delete',
      target: userId,
      payload: { email: user.email, role: user.role }
    });

    return {ok:true, deleted:true};
  });
}

/* -------------------------------- Utilities ----------------------------- */

function nowIso_(){ return new Date().toISOString(); }
function cuid_(){ return 'c_' + Utilities.getUuid().replace(/-/g,'').slice(0,18); }

/* ------------------------------ Test Runners ---------------------------- */

/** Minimal assertion helper */
function __assert_(cond, msg){ if(!cond) throw new Error('Test failed: ' + msg); }

/** Pick first tenant/app for tests */
function __pickFirstTenantAndApp_(){
  ensureSchema();
  const t = getAll_(SHEETS.Tenants)[0];
  const a = getAll_(SHEETS.Apps)[0];
  __assert_(t && a, 'Need at least one tenant and one app');
  return {tenant:t, app:a};
}

/** Test: schema bootstrap */
function testSchema_(){
  ensureSchema();
  __assert_(sheet_(SHEETS.Tenants).getLastRow() >= 1, 'Tenants sheet empty header');
  Logger.log('testSchema_: OK');
}

/** Test: install â†’ issue token â†’ uninstall (non-destructive where possible) */
function testInstallIssueUninstall_(){
  const {tenant, app} = __pickFirstTenantAndApp_();
  const actor = 'owner@demo.com';
  const installRes = hub_installApp({tenant_id:tenant.id, app_id:app.id, plan_id:'', settings:{DEMO:true}, actor_email:actor});
  __assert_(installRes.ok, 'install failed: ' + installRes.error);
  const install_id = installRes.install_id;

  const tokenRes = hub_issueToken(install_id, actor);
  __assert_(tokenRes.ok && tokenRes.token, 'issue token failed: ' + tokenRes.error);

  const rotateRes = rotateInstallSecret(install_id, actor);
  __assert_(rotateRes.ok, 'rotate failed: ' + rotateRes.error);

  const resendRes = resendInstallConfig(install_id, actor);
  __assert_(typeof resendRes.ok === 'boolean', 'resend returned invalid');

  const uninstallRes = hub_uninstallApp(install_id, actor);
  __assert_(uninstallRes.ok, 'uninstall failed: ' + uninstallRes.error);

  Logger.log('testInstallIssueUninstall_: OK');
}

/** Test: admin last-owner guard (create a user, try to demote/delete last owner) */
function testAdminGuards_(){
  ensureSchema();
  // Create a throwaway tenant with two owners to safely test
  const tId = cuid_();
  add_(SHEETS.Tenants, {id:tId, name:'Guard Test', slug:'guard', domain:'', logo_url:'', status:'active', created_at:nowIso_(), primary:'#2563eb', surface:'#ffffff', page:'#f7f6f3'});
  const u1 = {id:cuid_(), tenant_id:tId, email:'owner1@guard.test', name:'Owner1', role:'Owner', status:'active'};
  const u2 = {id:cuid_(), tenant_id:tId, email:'owner2@guard.test', name:'Owner2', role:'Owner', status:'active'};
  addMany_(SHEETS.Users, [u1,u2]);

  // Demote one owner (should succeed; not last owner)
  const demote = admin_updateUser('owner1@guard.test', u2.id, {role:'Admin'});
  __assert_(demote.ok, 'demote should succeed');

  // Try to demote last remaining owner -> should fail
  const failDemote = admin_updateUser('owner1@guard.test', u1.id, {role:'Admin'});
  __assert_(!failDemote.ok, 'demote last owner should fail');

  Logger.log('testAdminGuards_: OK');
}

/** Run all tests */
function runAllTests(){
  const t0 = Date.now();
  try {
    testSchema_();
    testInstallIssueUninstall_();
    testAdminGuards_();
    Logger.log('runAllTests(): ALL OK in ' + (Date.now()-t0) + 'ms');
  } catch (e) {
    Logger.log('runAllTests(): FAIL ' + e);
    throw e;
  }
}
